//TODO: ver o caso make && ./philo 10 310 150 100 - no da galera ninguém morre
//TODO: acho que faz mais sentido ter um mutex_fasting por filósofo, mas um geral em god tbm funciona

//TODO: stops when all phisolophers eat enough
//TODO: testar com 0, 1, 5, 10 e 200 filósofos. Testar com diferentes tempos e com -1 (ok), 0, n em times_to_eat. Usar algum tester tbm

//TODO: testar data race
//------------------
//DONE: Check if one philosopher died and finish execution
//DONE: Mutex the fork. O garfo tá disponível? Pego e seguro até o outro estar disponível.
//DONE: Soltar o garfo quando um deles não está disponível - No voy a hacer
//DONE: criar uma thread (outra rotina com mesmo god) que observa se os filósofos estão vivos e se um morreu imprime que ela morreu pq pense no exe: 2 filósofos
// que levam 300ms para comer e 200ms para morrer. Quando o primeiro come o segundo vai morrer em 200ms contudo como ele que vai printar
// sua morte, vai printar em 300 e não 200. make && ./philo 2 100 300 100. Isso acontece porque enquanto o 1 está comendo (com os dois garfos) o 2 está espereando sua
// vez no pthread_mutex_lock. Quando o 1 libera os garfos, 2 bloqueia o garfo e vai verificar se morreu. - OK
//DONE: talvez deva implementar mutex em all_alive. Não entendo como aparentemente funciona. Talvez tenha um data race aí. Checar com fsanitize. -> Sim,
// havia um data race nesse ponto porque ao mesmo tempo que um filósofo queria saber se todos estavam vivos, o observador estava alterando esse valor
//DONE: passar a thread para dentro do filósofo.
//DONE: criar exit_error function e limitar números de até 9 dígitos
//DONE: handle mutex init error, free pointers, destroy mutex etc.
//DONE: 1 filósofo morre e trava
//DONE:  ./philo 5000 10 20 30 termina sem ninguém morrer - limitei 4k filósofos
//DONE: ./philo 9999999 10 20 30 seg fault - limitei 4k filósofos
//DONE: ver porque nesse caso ./philo 5 410 200 200 sempre o zero morre primeiro - normal, em todos sempre se repete o filósofo que morre