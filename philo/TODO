//./philo 200 400 100 100 3 - morro antes de comer. No do Nacho e Aitor eles têm tempo de comer.
//Depois que morro eu demoro pra sair. Isso se percebe melhor quanto tenho muitos philos

//------------------
//DONE: Check if one philosopher died and finish execution
//DONE: Mutex the fork. O garfo tá disponível? Pego e seguro até o outro estar disponível.
//DONE: Soltar o garfo quando um deles não está disponível - No voy a hacer
//DONE: criar uma thread (outra rotina com mesmo god) que observa se os filósofos estão vivos e se um morreu imprime que ela morreu pq pense no exe: 2 filósofos
// que levam 300ms para comer e 200ms para morrer. Quando o primeiro come o segundo vai morrer em 200ms contudo como ele que vai printar
// sua morte, vai printar em 300 e não 200. make && ./philo 2 100 300 100. Isso acontece porque enquanto o 1 está comendo (com os dois garfos) o 2 está espereando sua
// vez no pthread_mutex_lock. Quando o 1 libera os garfos, 2 bloqueia o garfo e vai verificar se morreu. - OK
//DONE: talvez deva implementar mutex em all_alive. Não entendo como aparentemente funciona. Talvez tenha um data race aí. Checar com fsanitize. -> Sim,
// havia um data race nesse ponto porque ao mesmo tempo que um filósofo queria saber se todos estavam vivos, o observador estava alterando esse valor
//DONE: passar a thread para dentro do filósofo.
//DONE: criar exit_error function e limitar números de até 9 dígitos
//DONE: handle mutex init error, free pointers, destroy mutex etc.
//DONE: 1 filósofo morre e trava
//DONE:  ./philo 5000 10 20 30 termina sem ninguém morrer - limitei 4k filósofos
//DONE: ./philo 9999999 10 20 30 seg fault - limitei 4k filósofos
//DONE: ver porque nesse caso ./philo 5 410 200 200 sempre o zero morre primeiro - normal, em todos sempre se repete o filósofo que morre
//DONE:  ./philo 200 10 20 300 neste caso o filo morre em 150 e nao em 10
//DONE: no one should die: ./philo 4 410 200 200
//DONE: ver o caso make && ./philo 10 310 150 100 - no da galera se morre depois de muito tempo
//DONE: ./philo 10 310 150 100 ainda imprime, as vezes, uma em cinco, depois da morte, a depender de onde faço o lock
//pthread_mutex_lock(&god->mutex_all_alive) do observer
//DONE: acho que faz mais sentido ter um mutex_fasting por filósofo, mas um geral em god tbm funciona
//DONE: fazer my_time igual do Nacho
//DONE: criar usando mutex uma forma de fazer com que todas as threads comecem juntas
// e juntas com o observador
//DONE: rever a morte de 1 filo como fiz, não gostei
//DONE: mudar nome de fasting para last meal
//DONE:
//Outro ex: ./philo 10 400 200 100. 
//1. Eu morro (Julia não morrem porque faz > time enquanto eu >= time, Sebas sim, Nacho subtrai 10ms, Aitor tá mais tunado que carro com veneno)
//2. imprimo depois de morrer
//DONE: stops when all phisolophers eat enough
//Testes OK:
//./philo 200 100 100 3 - ok
//./philo 10 400 200 100 - ok
//./philo 200 10 20 300 - ok
//./philo 10 310 150 100 - ok
// - não pode imprimir depois de morrer
// - idealmente ninguem deve morrer
//DONE: testar data race - OK
//DONE: testar com 0, 1, 5, 10 e 200 filósofos. Testar com diferentes tempos e com -1 (ok), 0, n em times_to_eat.